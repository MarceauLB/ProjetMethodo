}
}
Hs <- 1/2
Ht <- 1/2
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
for(i in 1:N){
cov <- matrix(0,nrow = m,ncol = m)
for(t in 1:m){
for(s in 1:m){
cov[t,s] <- covts(tij[i,s],tij[i,t],Hs,Ht)
}
}
X[i,] <- mvrnorm(1,c(rep(0,m)),cov)
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
rm(list=ls())
library(MASS)
#------------------------------------------------------------
# Multi-fractional-gaussian-process
#------------------------------------------------------------
N <- 10
m <- 200
tij <- matrix(sort(runif(N*m,0,1)),nrow = N,ncol = m)
X <- matrix(0,nrow = N,ncol = m)
functionD <- function(x,y){
if(x==y){
return(1/2)
}else{
num <- sqrt(gamma(2*x+1)*gamma(2*y+1)*sin(pi*x)*sin(pi*y))
denom <- 2*gamma(x+y+1)*sin(pi*(x+y)/2)
return(num/denom)
}
}
Hs <- 1/2
Ht <- 1/2
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
for(i in 1:N){
cov <- matrix(0,nrow = m,ncol = m)
for(t in 1:m){
for(s in 1:m){
cov[t,s] <- covts(tij[i,s],tij[i,t],Hs,Ht)
}
}
X[i,] <- mvrnorm(1,c(rep(0,m)),cov)
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
rm(list=ls())
library(MASS)
#------------------------------------------------------------
# Multi-fractional-gaussian-process
#------------------------------------------------------------
N <- 10
m <- 200
tij <- matrix(sort(runif(N*m,0,1)),nrow = N,ncol = m)
X <- matrix(0,nrow = N,ncol = m)
functionD <- function(x,y){
if(x==y){
return(1/2)
}else{
num <- sqrt(gamma(2*x+1)*gamma(2*y+1)*sin(pi*x)*sin(pi*y))
denom <- 2*gamma(x+y+1)*sin(pi*(x+y)/2)
return(num/denom)
}
}
Hs <- 1/2
Ht <- 1/2
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
for(i in 1:N){
cov <- matrix(0,nrow = m,ncol = m)
for(t in 1:m){
for(s in 1:m){
cov[t,s] <- covts(tij[i,s],tij[i,t],Hs,Ht)
}
}
X[i,] <- mvrnorm(1,c(rep(0,m)),cov)
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
rm(list=ls())
library(MASS)
#------------------------------------------------------------
# Multi-fractional-gaussian-process
#------------------------------------------------------------
N <- 10
m <- 200
tij <- matrix(sort(runif(N*m,0,1)),nrow = N,ncol = m)
X <- matrix(0,nrow = N,ncol = m)
functionD <- function(x,y){
if(x==y){
return(1/2)
}else{
num <- sqrt(gamma(2*x+1)*gamma(2*y+1)*sin(pi*x)*sin(pi*y))
denom <- 2*gamma(x+y+1)*sin(pi*(x+y)/2)
return(num/denom)
}
}
Hs <- 0.7
Ht <- 0.2
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
for(i in 1:N){
cov <- matrix(0,nrow = m,ncol = m)
for(t in 1:m){
for(s in 1:m){
cov[t,s] <- covts(tij[i,s],tij[i,t],Hs,Ht)
}
}
X[i,] <- mvrnorm(1,c(rep(0,m)),cov)
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
return(0.3 + 0.4 * t)
H_function <- function(t) {
return(0.3 + 0.4 * t)
}
rm(list=ls())
library(MASS)
#------------------------------------------------------------
# Multi-fractional-gaussian-process
#------------------------------------------------------------
N <- 10
m <- 200
tij <- matrix(sort(runif(N*m,0,1)),nrow = N,ncol = m)
X <- matrix(0,nrow = N,ncol = m)
functionD <- function(x,y){
if(x==y){
return(1/2)
}else{
num <- sqrt(gamma(2*x+1)*gamma(2*y+1)*sin(pi*x)*sin(pi*y))
denom <- 2*gamma(x+y+1)*sin(pi*(x+y)/2)
return(num/denom)
}
}
H_function <- function(t) {
return(0.3 + 0.4 * t)
}
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
for(i in 1:N){
cov <- matrix(0,nrow = m,ncol = m)
for(t in 1:m){
for(s in 1:m){
cov[t,s] <- covts(tij[i,s],tij[i,t],H_function(tij[i,s]),H_function(tij[i,t]))
}
}
X[i,] <- mvrnorm(1,c(rep(0,m)),cov)
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red",     main = "Simulated Multifractional Brownian Motion (mBm)",
xlab = "Time", ylab = "mBm Value", lwd = 2)
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red",
main = "Simulated Multifractional Brownian Motion (mBm)",
xlab = "Time", ylab = "mBm Value")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
rm(list=ls())
library(MASS)
#------------------------------------------------------------
# Multi-fractional-gaussian-process
#------------------------------------------------------------
N <- 10
m <- 200
tij <- matrix(sort(runif(N*m,0,1)),nrow = N,ncol = m)
X <- matrix(0,nrow = N,ncol = m)
functionD <- function(x,y){
if(x==y){
return(1/2)
}else{
num <- sqrt(gamma(2*x+1)*gamma(2*y+1)*sin(pi*x)*sin(pi*y))
denom <- 2*gamma(x+y+1)*sin(pi*(x+y)/2)
return(num/denom)
}
}
H_function <- function(t) {
return(0.3 + 0.4 * t)
}
covts <- function(s,t,Hs,Ht){
D_ts <- functionD(Hs,Ht)
out <- D_ts*(abs(s)**(Hs+Ht) + abs(t)**(Hs+Ht) - abs(t-s)**(Hs+Ht))
return(out)
}
for(i in 1:N){
cov <- matrix(0,nrow = m,ncol = m)
for(t in 1:m){
for(s in 1:m){
cov[t,s] <- covts(tij[i,s],tij[i,t],H_function(tij[i,s]),H_function(tij[i,t]))
}
}
X[i,] <- mvrnorm(1,c(rep(0,m)),cov)
}
plot(tij[1,],X[1,],ylim = range(X),type="l",col="red",
main = "Simulated Multifractional Brownian Motion (mBm)",
xlab = "Time", ylab = "mBm Value")
for(i in 2:N){
lines(tij[i,],X[i,],col=rainbow(N)[i])
}
rm(list=ls())
X <- matrix(rnorm(n*p,0,1),n,p)
n <- 200
n <- 20
p <- 10
X <- matrix(rnorm(n*p,0,1),n,p)
X
n <- 15
p <- 6
X <- matrix(rnorm(n*p,0,1),n,p)
X
Y <- sample(c(0,1),n)
Y <- sample(c(0,1),n,replace = TRUE)
Y
library(calibrateBinary)
p <- 1
n <- 15
p <- 1
np <- 10
np
n <- 10
p <- 1
np <- 10
xp <- seq(0,1,length.out = np)
xp
n <- 10
p <- 1
np <- 10
xp <- seq(0,1,length.out = np)
rm(list=ls())
setwd("~/00_Ensai/projet-methodo/ProjetMethodo/real-word-datasets")
X <- read.csv("dataset_csv/ar10p.csv")
X
dim(X)
n <- dim(X)[1]
p <- dim(X)[2]-1
p
Y <- X[,-1:p]
Y <- X[,-(1:p)]
Y
X <- X[,-(p+1)]
X
round(0.8*n)
indices <- sample(1:n,size = round(0.8*n))
indices <- sample(1:n,size = round(0.8*n),replace=FALSE)
indices
X_train <- X[indices,]
X_train
Y_train <- Y[indices,]
X_test <- X[-indices,]
Y_test <- Y[-indices,]
rm(list=ls())
X <- read.csv("dataset_csv/ar10p.csv")
n <- dim(X)[1]
p <- dim(X)[2]-1
Y <- X[,-(1:p)]
X <- X[,-(p+1)]
indices <- sample(1:n,size = round(0.8*n),replace=FALSE)
X_train <- X[indices,]
Y_train <- Y[indices,]
rm(list=ls())
X <- read.csv("dataset_csv/ar10p.csv")
n <- dim(X)[1]
p <- dim(X)[2]-1
Y <- X[,-(1:p)]
X <- X[,-(p+1)]
indices <- sample(1:n,size = round(0.8*n),replace=FALSE)
X_train <- X[indices,]
Y_train <- Y[indices]
X_test <- X[-indices,]
Y_test <- Y[-indices]
library(GSelection)
res_hsic <- feature.selection(X_train,Y_train,d=50)
res_hsic$coefficient.hsic
res_hsic$coefficient.hsic
res_hsic$hsic_selected_feature_index
library(paraznik)
library(praznik*)
library(praznik)
resmrmr <- MRMR(X_train, Y_train,50)
resmrmr
resmrmr$score
?MRMR
as.matrix(resmrmr$score)
restable_mrmr <- as.matrix(resmrmr$score)
restable_mrmr <- as.data.frame(as.matrix(resmrmr$score))
restable_mrmr <- as.data.frame(as.matrix(resmrmr$score))
restable_mrmr
restable_mrmr$V1
resmrmr$score
restable_mrmr <- as.data.frame(as.matrix(resmrmr$score,ncol=2))
restable_mrmr
restable_mrmr
restable_mrmr <- as.data.frame(as.matrix(resmrmr$score))
restable_mrmr <- as.data.frame(resmrmr$score)
restable_mrmr
restable_mrmr
resmrmr
restable_mrmr <- as.data.frame(resmrmr)
restable_mrmr
resmrmr20 <- MRMR(X_train, Y_train,20)
resmrmr20
resmrmr
resmrmr20
library(glmnet)
?glmnet
resglmnet <- glmnet(X_train, Y_train,alpha=1)
resglmnet <- glmnet(X_train, Y_train,alpha=1)
cv_fit <- cv.glmnet(X_train, Y_train,alpha=1)
resglmnet <- glmnet(X_train, Y_train,alpha=1)
cv_fit <- cv.glmnet(X_train, Y_train,alpha=1)
resglmnet <- glmnet(X_train, Y_train,alpha=1)
cv_fit <- cv.glmnet(X_train, Y_train,alpha=1)
cv_fit <- cv.glmnet(as.matrix(X_train), Y_train,alpha=1)
cv_fit
cv_fit$lambda
cv_fit$lambda.min
lambda_opt <- cv_fit$lambda.min
coefficients <- as.numeric(coef(cv_fit, s = "lambda.min"))[-1]  # Exclure l'intercept
coefficients
resglmnet$beta
resglmnet_opt <- glmnet(X_train, Y_train,alpha=1,lambda = lambda_opt)
resglmnet_opt
resglmnet_opt$beta
resglmnet_opt$beta
cv_fit
coef(cv_fit, s = "lambda.min")
as.numeric(coef(cv_fit, s = "lambda.min"))
coefficients <- as.numeric(coef(cv_fit, s = "lambda.min"))[-1]
coefficients
abs(coefficients)
order(abs(coefficients), decreasing = TRUE)
order(abs(coefficients), decreasing = TRUE)[1:d]
order(abs(coefficients), decreasing = TRUE)[1:d]
order(abs(coefficients), decreasing = TRUE)[1:50]
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
data
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
data
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
Y
X <- as.matrix(data)
X
n <- 20
p <- 200
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
spam <- samQL(X,Y)
library(SAM)
spam <- samQL(X,Y)
spam$lambda
spam$func_norm
spam
spam$lambda
spam$func_norm
spam$lambda
spam <- samQL(X,Y)
spam$lambda
spam <- samQL(X,Y)
spam$lambda
spam$func_norm
spam$lambda
X_indice_train <- sample(c(1:nX),size = round(0.8*nX),replace = FALSE)
nX <- dim(X)[1]
pX <- dim(X)[2]
X_indice_train <- sample(c(1:nX),size = round(0.8*nX),replace = FALSE)
X_train <- X[X_indice_train,]
Y_train <- Y[X_indice_train]
X_val <- X[-X_indice_train,]
Y_val <- Y[-X_indice_train]
res_samQL <- samQL(X_train, Y_train)
grid_lamb <- res_samQL$lambda
grid_lamb
res_samQL
prediction <- predict(res_samQL,X_val)
n <- 30
p <- 200
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
nX <- dim(X)[1]
pX <- dim(X)[2]
X_indice_train <- sample(c(1:nX),size = round(0.8*nX),replace = FALSE)
X_train <- X[X_indice_train,]
Y_train <- Y[X_indice_train]
X_val <- X[-X_indice_train,]
Y_val <- Y[-X_indice_train]
res_samQL <- samQL(X_train, Y_train)
grid_lamb <- res_samQL$lambda
prediction <- predict(res_samQL,X_val)
y_pred_val <- prediction$values
n <- 40
p <- 250
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
X_indice_train <- sample(c(1:nX),size = round(0.8*nX),replace = FALSE)
X_train <- X[X_indice_train,]
Y_train <- Y[X_indice_train]
X_val <- X[-X_indice_train,]
Y_val <- Y[-X_indice_train]
res_samQL <- samQL(X_train, Y_train)
grid_lamb <- res_samQL$lambda
prediction <- predict(res_samQL,X_val)
n <- 200
p <- 250
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
X_indice_train <- sample(c(1:nX),size = round(0.8*nX),replace = FALSE)
X_train <- X[X_indice_train,]
Y_train <- Y[X_indice_train]
X_val <- X[-X_indice_train,]
Y_val <- Y[-X_indice_train]
res_samQL <- samQL(X_train, Y_train)
grid_lamb <- res_samQL$lambda
prediction <- predict(res_samQL,X_val)
y_pred_val <- prediction$values
y_pred_val
n <- 200
p <- 250
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
spam <- samQL(X,Y)
spam <- samQL(X,Y)
spam$lambda
n <- 200
p <- 250
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
spam <- samQL(X,Y)
spam$lambda
n <- 200
p <- 250
data <- as.data.frame(matrix(rnorm(n * p, mean = 0, sd = 1), nrow = n, ncol = p))
colnames(data) <- paste0("X_", 1:p)
epsilon <- rnorm(n,0,1)
Y <- -2*sin(2*data$X_1) + (data$X_2)**2 + data$X_3 + exp(-data$X_4) + epsilon
X <- as.matrix(data)
spam <- samQL(X,Y)
spam$lambda
X_indice_train <- sample(c(1:nX),size = round(0.8*nX),replace = FALSE)
X_train <- X[X_indice_train,]
Y_train <- Y[X_indice_train]
X_val <- X[-X_indice_train,]
Y_val <- Y[-X_indice_train]
spam <- samQL(X_train,Y_train)
spam
spam <- samQL(X_train,Y_train)
spam$lambda
predict(spam,X_test)
predict(spam,X_val)
y_pred <- predict(spam,X_val)
order(colMeans((y_pred - Y_val)**2),decreasing = FALSE)
spam$lambda
y_pred <- predict(spam,X_val)
y_pred
order(colMeans((y_pred - Y_val)**2),decreasing = FALSE)
order(colMeans((y_pred$values - Y_val)**2),decreasing = FALSE)
